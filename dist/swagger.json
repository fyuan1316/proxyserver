{
  "swagger": "2.0",
  "info": {
    "title": "tf-serving.proto",
    "version": "version not set"
  },
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/alauda/v1/models/testmodel": {
      "get": {
        "summary": "Gets status of model. If the ModelSpec in the request does not specify\nversion, information about all versions of the model will be returned. If\nthe ModelSpec in the request does specify a version, the status of only\nthat version will be returned.",
        "operationId": "GetModelStatus",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/servingGetModelStatusResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "model_spec.name",
            "description": "Required servable name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "model_spec.version",
            "description": "Use this specific version number.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "model_spec.version_label",
            "description": "Use the version associated with the given label.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "model_spec.signature_name",
            "description": "A named signature to evaluate. If unspecified, the default signature will\nbe used.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ModelService"
        ]
      }
    },
    "/alauda/v1/models/testmodel/metadata": {
      "get": {
        "summary": "GetModelMetadata - provides access to metadata for loaded models.",
        "operationId": "GetModelMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/servingGetModelMetadataResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "model_spec.name",
            "description": "Required servable name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "model_spec.version",
            "description": "Use this specific version number.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "model_spec.version_label",
            "description": "Use the version associated with the given label.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "model_spec.signature_name",
            "description": "A named signature to evaluate. If unspecified, the default signature will\nbe used.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "metadata_field",
            "description": "Metadata fields to get. Currently supported: \"signature_def\".",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          }
        ],
        "tags": [
          "PredictionService"
        ]
      }
    },
    "/alauda/v1/models/testmodel:classify": {
      "post": {
        "summary": "Classify.",
        "operationId": "Classify",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/servingClassificationResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/servingClassificationRequest"
            }
          }
        ],
        "tags": [
          "PredictionService"
        ]
      }
    },
    "/alauda/v1/models/testmodel:predict": {
      "post": {
        "summary": "Predict -- provides access to loaded TensorFlow model.",
        "operationId": "Predict",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/servingPredictResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/servingPredictRequest"
            }
          }
        ],
        "tags": [
          "PredictionService"
        ]
      }
    },
    "/alauda/v1/models/testmodel:regress": {
      "post": {
        "summary": "Regress.",
        "operationId": "Regress",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/servingRegressionResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/servingRegressionRequest"
            }
          }
        ],
        "tags": [
          "PredictionService"
        ]
      }
    }
  },
  "definitions": {
    "FileSystemStoragePathSourceConfigServableVersionPolicy": {
      "type": "object",
      "properties": {
        "latest": {
          "$ref": "#/definitions/ServableVersionPolicyLatest"
        },
        "all": {
          "$ref": "#/definitions/ServableVersionPolicyAll"
        },
        "specific": {
          "$ref": "#/definitions/ServableVersionPolicySpecific"
        }
      },
      "description": "A policy that dictates which version(s) of a servable should be served."
    },
    "ModelVersionStatusState": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "START",
        "LOADING",
        "AVAILABLE",
        "UNLOADING",
        "END"
      ],
      "default": "UNKNOWN",
      "description": "- UNKNOWN: Default value.\n - START: The manager is tracking this servable, but has not initiated any action\npertaining to it.\n - LOADING: The manager has decided to load this servable. In particular, checks\naround resource availability and other aspects have passed, and the\nmanager is about to invoke the loader's Load() method.\n - AVAILABLE: The manager has successfully loaded this servable and made it available\nfor serving (i.e. GetServableHandle(id) will succeed). To avoid races,\nthis state is not reported until *after* the servable is made\navailable.\n - UNLOADING: The manager has decided to make this servable unavailable, and unload\nit. To avoid races, this state is reported *before* the servable is\nmade unavailable.\n - END: This servable has reached the end of its journey in the manager. Either\nit loaded and ultimately unloaded successfully, or it hit an error at\nsome point in its lifecycle.",
      "title": "States that map to ManagerState enum in\ntensorflow_serving/core/servable_state.h"
    },
    "ServableVersionPolicyAll": {
      "type": "object",
      "description": "Serve all versions found on disk."
    },
    "ServableVersionPolicyLatest": {
      "type": "object",
      "properties": {
        "num_versions": {
          "type": "integer",
          "format": "int64",
          "title": "Number of latest versions to serve. (The default is 1.)"
        }
      },
      "description": "Serve the latest versions (i.e. the ones with the highest version\nnumbers), among those found on disk.\n\nThis is the default policy, with the default number of versions as 1."
    },
    "ServableVersionPolicySpecific": {
      "type": "object",
      "properties": {
        "versions": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          },
          "description": "The version numbers to serve."
        }
      },
      "description": "Serve a specific version (or set of versions).\n\nThis policy is useful for rolling back to a specific version, or for\ncanarying a specific version while still serving a separate stable\nversion."
    },
    "TensorShapeProtoDim": {
      "type": "object",
      "properties": {
        "size": {
          "type": "string",
          "format": "int64",
          "description": "Size of the tensor in that dimension.\nThis value must be \u003e= -1, but values of -1 are reserved for \"unknown\"\nshapes (values of -1 mean \"unknown\" dimension).  Certain wrappers\nthat work with TensorShapeProto may fail at runtime when deserializing\na TensorShapeProto containing a dim value of -1."
        },
        "name": {
          "type": "string",
          "description": "Optional name of the tensor dimension."
        }
      },
      "description": "One dimension of the tensor."
    },
    "errorCode": {
      "type": "string",
      "enum": [
        "OK",
        "CANCELLED",
        "UNKNOWN",
        "INVALID_ARGUMENT",
        "DEADLINE_EXCEEDED",
        "NOT_FOUND",
        "ALREADY_EXISTS",
        "PERMISSION_DENIED",
        "UNAUTHENTICATED",
        "RESOURCE_EXHAUSTED",
        "FAILED_PRECONDITION",
        "ABORTED",
        "OUT_OF_RANGE",
        "UNIMPLEMENTED",
        "INTERNAL",
        "UNAVAILABLE",
        "DATA_LOSS",
        "DO_NOT_USE_RESERVED_FOR_FUTURE_EXPANSION_USE_DEFAULT_IN_SWITCH_INSTEAD_"
      ],
      "default": "OK",
      "description": "The canonical error codes for TensorFlow APIs.\n\nWarnings:\n\n-   Do not change any numeric assignments.\n-   Changes to this list should only be made if there is a compelling\n    need that can't be satisfied in another way.  Such changes\n    must be approved by at least two OWNERS.\n\nSometimes multiple error codes may apply.  Services should return\nthe most specific error code that applies.  For example, prefer\nOUT_OF_RANGE over FAILED_PRECONDITION if both codes apply.\nSimilarly prefer NOT_FOUND or ALREADY_EXISTS over FAILED_PRECONDITION.\n\n - OK: Not an error; returned on success\n - CANCELLED: The operation was cancelled (typically by the caller).\n - UNKNOWN: Unknown error.  An example of where this error may be returned is\nif a Status value received from another address space belongs to\nan error-space that is not known in this address space.  Also\nerrors raised by APIs that do not return enough error information\nmay be converted to this error.\n - INVALID_ARGUMENT: Client specified an invalid argument.  Note that this differs\nfrom FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments\nthat are problematic regardless of the state of the system\n(e.g., a malformed file name).\n - DEADLINE_EXCEEDED: Deadline expired before operation could complete.  For operations\nthat change the state of the system, this error may be returned\neven if the operation has completed successfully.  For example, a\nsuccessful response from a server could have been delayed long\nenough for the deadline to expire.\n - NOT_FOUND: Some requested entity (e.g., file or directory) was not found.\nFor privacy reasons, this code *may* be returned when the client\ndoes not have the access right to the entity.\n - ALREADY_EXISTS: Some entity that we attempted to create (e.g., file or directory)\nalready exists.\n - PERMISSION_DENIED: The caller does not have permission to execute the specified\noperation.  PERMISSION_DENIED must not be used for rejections\ncaused by exhausting some resource (use RESOURCE_EXHAUSTED\ninstead for those errors).  PERMISSION_DENIED must not be\nused if the caller can not be identified (use UNAUTHENTICATED\ninstead for those errors).\n - UNAUTHENTICATED: The request does not have valid authentication credentials for the\noperation.\n - RESOURCE_EXHAUSTED: Some resource has been exhausted, perhaps a per-user quota, or\nperhaps the entire file system is out of space.\n - FAILED_PRECONDITION: Operation was rejected because the system is not in a state\nrequired for the operation's execution.  For example, directory\nto be deleted may be non-empty, an rmdir operation is applied to\na non-directory, etc.\n\nA litmus test that may help a service implementor in deciding\nbetween FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n (a) Use UNAVAILABLE if the client can retry just the failing call.\n (b) Use ABORTED if the client should retry at a higher-level\n     (e.g., restarting a read-modify-write sequence).\n (c) Use FAILED_PRECONDITION if the client should not retry until\n     the system state has been explicitly fixed.  E.g., if an \"rmdir\"\n     fails because the directory is non-empty, FAILED_PRECONDITION\n     should be returned since the client should not retry unless\n     they have first fixed up the directory by deleting files from it.\n (d) Use FAILED_PRECONDITION if the client performs conditional\n     REST Get/Update/Delete on a resource and the resource on the\n     server does not match the condition. E.g., conflicting\n     read-modify-write on the same resource.\n - ABORTED: The operation was aborted, typically due to a concurrency issue\nlike sequencer check failures, transaction aborts, etc.\n\nSee litmus test above for deciding between FAILED_PRECONDITION,\nABORTED, and UNAVAILABLE.\n - OUT_OF_RANGE: Operation tried to iterate past the valid input range.  E.g., seeking or\nreading past end of file.\n\nUnlike INVALID_ARGUMENT, this error indicates a problem that may\nbe fixed if the system state changes. For example, a 32-bit file\nsystem will generate INVALID_ARGUMENT if asked to read at an\noffset that is not in the range [0,2^32-1], but it will generate\nOUT_OF_RANGE if asked to read from an offset past the current\nfile size.\n\nThere is a fair bit of overlap between FAILED_PRECONDITION and\nOUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific\nerror) when it applies so that callers who are iterating through\na space can easily look for an OUT_OF_RANGE error to detect when\nthey are done.\n - UNIMPLEMENTED: Operation is not implemented or not supported/enabled in this service.\n - INTERNAL: Internal errors.  Means some invariant expected by the underlying\nsystem has been broken.  If you see one of these errors,\nsomething is very broken.\n - UNAVAILABLE: The service is currently unavailable.  This is a most likely a\ntransient condition and may be corrected by retrying with\na backoff.\n\nSee litmus test above for deciding between FAILED_PRECONDITION,\nABORTED, and UNAVAILABLE.\n - DATA_LOSS: Unrecoverable data loss or corruption.\n - DO_NOT_USE_RESERVED_FOR_FUTURE_EXPANSION_USE_DEFAULT_IN_SWITCH_INSTEAD_: An extra enum entry to prevent people from writing code that\nfails to compile when a new code is added.\n\nNobody should ever reference this enumeration entry. In particular,\nif you write C++ code that switches on this enumeration, add a default:\ncase instead of a case that mentions this enumeration entry.\n\nNobody should rely on the value (currently 20) listed here.  It\nmay change in the future."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "servingClass": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string",
          "description": "Label or name of the class."
        },
        "score": {
          "type": "number",
          "format": "float",
          "description": "Score for this class (e.g., the probability the item belongs to this\nclass). As per the proto3 default-value semantics, if the score is missing,\nit should be treated as 0."
        }
      },
      "description": "A single class."
    },
    "servingClassificationRequest": {
      "type": "object",
      "properties": {
        "model_spec": {
          "$ref": "#/definitions/servingModelSpec",
          "description": "Model Specification. If version is not specified, will use the latest\n(numerical) version."
        },
        "input": {
          "$ref": "#/definitions/servingInput",
          "description": "Input data."
        }
      }
    },
    "servingClassificationResponse": {
      "type": "object",
      "properties": {
        "model_spec": {
          "$ref": "#/definitions/servingModelSpec",
          "description": "Effective Model Specification used for classification."
        },
        "result": {
          "$ref": "#/definitions/servingClassificationResult",
          "description": "Result of the classification."
        }
      }
    },
    "servingClassificationResult": {
      "type": "object",
      "properties": {
        "classifications": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/servingClassifications"
          }
        }
      },
      "description": "Contains one result per input example, in the same order as the input in\nClassificationRequest."
    },
    "servingClassifications": {
      "type": "object",
      "properties": {
        "classes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/servingClass"
          }
        }
      },
      "description": "List of classes for a single item (tensorflow.Example)."
    },
    "servingExampleList": {
      "type": "object",
      "properties": {
        "examples": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/tensorflowExample"
          }
        }
      },
      "title": "Specifies one or more fully independent input Examples.\nSee examples at:\n    https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/example/example.proto"
    },
    "servingExampleListWithContext": {
      "type": "object",
      "properties": {
        "examples": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/tensorflowExample"
          }
        },
        "context": {
          "$ref": "#/definitions/tensorflowExample"
        }
      },
      "description": "Specifies one or more independent input Examples, with a common context\nExample.\n\nThe common use case for context is to cleanly and optimally specify some\nfeatures that are common across multiple examples.\n\nSee example below with a search query as the context and multiple restaurants\nto perform some inference on.\n\ncontext: {\n  feature: {\n    key  : \"query\"\n    value: {\n      bytes_list: {\n        value: [ \"pizza\" ]\n      }\n    }\n  }\n}\nexamples: {\n  feature: {\n    key  : \"cuisine\"\n    value: {\n      bytes_list: {\n        value: [ \"Pizzeria\" ]\n      }\n    }\n  }\n}\nexamples: {\n  feature: {\n    key  : \"cuisine\"\n    value: {\n      bytes_list: {\n        value: [ \"Taqueria\" ]\n      }\n    }\n  }\n}\n\nImplementations of ExampleListWithContext merge the context Example into each\nof the Examples. Note that feature keys must not be duplicated between the\nExamples and context Example, or the behavior is undefined.\n\nSee also:\n    tensorflow/core/example/example.proto\n    https://developers.google.com/protocol-buffers/docs/proto3#maps"
    },
    "servingGetModelMetadataResponse": {
      "type": "object",
      "properties": {
        "model_spec": {
          "$ref": "#/definitions/servingModelSpec",
          "description": "Model Specification indicating which model this metadata belongs to."
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Map of metadata field name to metadata field. The options for metadata\nfield name are listed in GetModelMetadataRequest. Currently supported:\n\"signature_def\"."
        }
      }
    },
    "servingGetModelStatusResponse": {
      "type": "object",
      "properties": {
        "model_version_status": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/servingModelVersionStatus"
          },
          "description": "Version number and status information for applicable model version(s)."
        }
      },
      "description": "Response for ModelStatusRequest on successful run."
    },
    "servingInput": {
      "type": "object",
      "properties": {
        "example_list": {
          "$ref": "#/definitions/servingExampleList"
        },
        "example_list_with_context": {
          "$ref": "#/definitions/servingExampleListWithContext"
        }
      }
    },
    "servingLogCollectorConfig": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Identifies the type of the LogCollector we will use to collect these logs."
        },
        "filename_prefix": {
          "type": "string",
          "description": "The prefix to use for the filenames of the logs."
        }
      }
    },
    "servingLoggingConfig": {
      "type": "object",
      "properties": {
        "log_collector_config": {
          "$ref": "#/definitions/servingLogCollectorConfig"
        },
        "sampling_config": {
          "$ref": "#/definitions/servingSamplingConfig"
        }
      },
      "description": "Configuration for logging query/responses."
    },
    "servingModelConfig": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the model."
        },
        "base_path": {
          "type": "string",
          "description": "Base path to the model, excluding the version directory.\nE.g\u003e for a model at /foo/bar/my_model/123, where 123 is the version, the\nbase path is /foo/bar/my_model.\n\n(This can be changed once a model is in serving, *if* the underlying data\nremains the same. Otherwise there are no guarantees about whether the old\nor new data will be used for model versions currently loaded.)"
        },
        "model_type": {
          "$ref": "#/definitions/servingModelType",
          "description": "Type of model.\nTODO(b/31336131): DEPRECATED. Please use 'model_platform' instead."
        },
        "model_platform": {
          "type": "string",
          "description": "Type of model (e.g. \"tensorflow\").\n\n(This cannot be changed once a model is in serving.)"
        },
        "model_version_policy": {
          "$ref": "#/definitions/FileSystemStoragePathSourceConfigServableVersionPolicy",
          "description": "Version policy for the model indicating which version(s) of the model to\nload and make available for serving simultaneously.\nThe default option is to serve only the latest version of the model.\n\n(This can be changed once a model is in serving.)"
        },
        "version_labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          },
          "description": "String labels to associate with versions of the model, allowing inference\nqueries to refer to versions by label instead of number. Multiple labels\ncan map to the same version, but not vice-versa.\n\nAn envisioned use-case for these labels is canarying tentative versions.\nFor example, one can assign labels \"stable\" and \"canary\" to two specific\nversions. Perhaps initially \"stable\" is assigned to version 0 and \"canary\"\nto version 1. Once version 1 passes canary, one can shift the \"stable\"\nlabel to refer to version 1 (at that point both labels map to the same\nversion -- version 1 -- which is fine). Later once version 2 is ready to\ncanary one can move the \"canary\" label to version 2. And so on."
        },
        "logging_config": {
          "$ref": "#/definitions/servingLoggingConfig",
          "description": "Configures logging requests and responses, to the model.\n\n(This can be changed once a model is in serving.)"
        }
      },
      "description": "Common configuration for loading a model being served."
    },
    "servingModelConfigList": {
      "type": "object",
      "properties": {
        "config": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/servingModelConfig"
          }
        }
      },
      "description": "Static list of models to be loaded for serving."
    },
    "servingModelServerConfig": {
      "type": "object",
      "properties": {
        "model_config_list": {
          "$ref": "#/definitions/servingModelConfigList"
        },
        "custom_model_config": {
          "$ref": "#/definitions/protobufAny"
        }
      },
      "description": "ModelServer config."
    },
    "servingModelSpec": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Required servable name."
        },
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Use this specific version number."
        },
        "version_label": {
          "type": "string",
          "description": "Use the version associated with the given label."
        },
        "signature_name": {
          "type": "string",
          "description": "A named signature to evaluate. If unspecified, the default signature will\nbe used."
        }
      },
      "description": "Metadata for an inference request such as the model name and version."
    },
    "servingModelType": {
      "type": "string",
      "enum": [
        "MODEL_TYPE_UNSPECIFIED",
        "TENSORFLOW",
        "OTHER"
      ],
      "default": "MODEL_TYPE_UNSPECIFIED",
      "description": "The type of model.\nTODO(b/31336131): DEPRECATED."
    },
    "servingModelVersionStatus": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Model version."
        },
        "state": {
          "$ref": "#/definitions/ModelVersionStatusState",
          "description": "Model state."
        },
        "status": {
          "$ref": "#/definitions/servingStatusProto",
          "description": "Model status."
        }
      },
      "description": "Version number, state, and status for a single version of a model."
    },
    "servingPredictRequest": {
      "type": "object",
      "properties": {
        "model_spec": {
          "$ref": "#/definitions/servingModelSpec",
          "description": "Model Specification. If version is not specified, will use the latest\n(numerical) version."
        },
        "inputs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/tensorflowTensorProto"
          },
          "description": "Input tensors.\nNames of input tensor are alias names. The mapping from aliases to real\ninput tensor names is stored in the SavedModel export as a prediction\nSignatureDef under the 'inputs' field."
        },
        "output_filter": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Output filter.\nNames specified are alias names. The mapping from aliases to real output\ntensor names is stored in the SavedModel export as a prediction\nSignatureDef under the 'outputs' field.\nOnly tensors specified here will be run/fetched and returned, with the\nexception that when none is specified, all tensors specified in the\nnamed signature will be run/fetched and returned."
        }
      },
      "description": "PredictRequest specifies which TensorFlow model to run, as well as\nhow inputs are mapped to tensors and how outputs are filtered before\nreturning to user."
    },
    "servingPredictResponse": {
      "type": "object",
      "properties": {
        "model_spec": {
          "$ref": "#/definitions/servingModelSpec",
          "description": "Effective Model Specification used to process PredictRequest."
        },
        "outputs": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/tensorflowTensorProto"
          },
          "description": "Output tensors."
        }
      },
      "description": "Response for PredictRequest on successful run."
    },
    "servingRegression": {
      "type": "object",
      "properties": {
        "value": {
          "type": "number",
          "format": "float"
        }
      },
      "description": "Regression result for a single item (tensorflow.Example)."
    },
    "servingRegressionRequest": {
      "type": "object",
      "properties": {
        "model_spec": {
          "$ref": "#/definitions/servingModelSpec",
          "description": "Model Specification. If version is not specified, will use the latest\n(numerical) version."
        },
        "input": {
          "$ref": "#/definitions/servingInput",
          "description": "Input data."
        }
      }
    },
    "servingRegressionResponse": {
      "type": "object",
      "properties": {
        "model_spec": {
          "$ref": "#/definitions/servingModelSpec",
          "description": "Effective Model Specification used for regression."
        },
        "result": {
          "$ref": "#/definitions/servingRegressionResult"
        }
      }
    },
    "servingRegressionResult": {
      "type": "object",
      "properties": {
        "regressions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/servingRegression"
          }
        }
      },
      "description": "Contains one result per input example, in the same order as the input in\nRegressionRequest."
    },
    "servingReloadConfigResponse": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/servingStatusProto"
        }
      }
    },
    "servingSamplingConfig": {
      "type": "object",
      "properties": {
        "sampling_rate": {
          "type": "number",
          "format": "double",
          "description": "Requests will be logged uniformly at random with this probability. Valid\nrange: [0, 1.0]."
        }
      }
    },
    "servingStatusProto": {
      "type": "object",
      "properties": {
        "error_code": {
          "$ref": "#/definitions/errorCode",
          "description": "Error code."
        },
        "error_message": {
          "type": "string",
          "description": "Error message. Will only be set if an error was encountered."
        }
      },
      "description": "Status that corresponds to Status in\nthird_party/tensorflow/core/lib/core/status.h."
    },
    "tensorflowBytesList": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          }
        }
      },
      "description": "Containers to hold repeated fundamental values."
    },
    "tensorflowDataType": {
      "type": "string",
      "enum": [
        "DT_INVALID",
        "DT_FLOAT",
        "DT_DOUBLE",
        "DT_INT32",
        "DT_UINT8",
        "DT_INT16",
        "DT_INT8",
        "DT_STRING",
        "DT_COMPLEX64",
        "DT_INT64",
        "DT_BOOL",
        "DT_QINT8",
        "DT_QUINT8",
        "DT_QINT32",
        "DT_BFLOAT16",
        "DT_QINT16",
        "DT_QUINT16",
        "DT_UINT16",
        "DT_COMPLEX128",
        "DT_HALF",
        "DT_RESOURCE",
        "DT_VARIANT",
        "DT_UINT32",
        "DT_UINT64",
        "DT_FLOAT_REF",
        "DT_DOUBLE_REF",
        "DT_INT32_REF",
        "DT_UINT8_REF",
        "DT_INT16_REF",
        "DT_INT8_REF",
        "DT_STRING_REF",
        "DT_COMPLEX64_REF",
        "DT_INT64_REF",
        "DT_BOOL_REF",
        "DT_QINT8_REF",
        "DT_QUINT8_REF",
        "DT_QINT32_REF",
        "DT_BFLOAT16_REF",
        "DT_QINT16_REF",
        "DT_QUINT16_REF",
        "DT_UINT16_REF",
        "DT_COMPLEX128_REF",
        "DT_HALF_REF",
        "DT_RESOURCE_REF",
        "DT_VARIANT_REF",
        "DT_UINT32_REF",
        "DT_UINT64_REF"
      ],
      "default": "DT_INVALID",
      "description": "- DT_INVALID: Not a legal value for DataType.  Used to indicate a DataType field\nhas not been set.\n - DT_FLOAT: Data types that all computation devices are expected to be\ncapable to support.\n - DT_FLOAT_REF: Do not use!  These are only for parameters.  Every enum above\nshould have a corresponding value below (verified by types_test).",
      "title": "(== suppress_warning documentation-presence ==)\nLINT.IfChange"
    },
    "tensorflowExample": {
      "type": "object",
      "properties": {
        "features": {
          "$ref": "#/definitions/tensorflowFeatures"
        }
      }
    },
    "tensorflowFeature": {
      "type": "object",
      "properties": {
        "bytes_list": {
          "$ref": "#/definitions/tensorflowBytesList"
        },
        "float_list": {
          "$ref": "#/definitions/tensorflowFloatList"
        },
        "int64_list": {
          "$ref": "#/definitions/tensorflowInt64List"
        }
      },
      "description": "Containers for non-sequential data."
    },
    "tensorflowFeatures": {
      "type": "object",
      "properties": {
        "feature": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/tensorflowFeature"
          },
          "description": "Map from feature name to feature."
        }
      }
    },
    "tensorflowFloatList": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          }
        }
      }
    },
    "tensorflowInt64List": {
      "type": "object",
      "properties": {
        "value": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          }
        }
      }
    },
    "tensorflowResourceHandleProto": {
      "type": "object",
      "properties": {
        "device": {
          "type": "string",
          "description": "Unique name for the device containing the resource."
        },
        "container": {
          "type": "string",
          "description": "Container in which this resource is placed."
        },
        "name": {
          "type": "string",
          "description": "Unique name of this resource."
        },
        "hash_code": {
          "type": "string",
          "format": "uint64",
          "description": "Hash code for the type of the resource. Is only valid in the same device\nand in the same execution."
        },
        "maybe_type_name": {
          "type": "string",
          "description": "For debug-only, the name of the type pointed to by this handle, if\navailable."
        }
      },
      "description": "Protocol buffer representing a handle to a tensorflow resource. Handles are\nnot valid across executions, but can be serialized back and forth from within\na single run."
    },
    "tensorflowTensorProto": {
      "type": "object",
      "properties": {
        "dtype": {
          "$ref": "#/definitions/tensorflowDataType"
        },
        "tensor_shape": {
          "$ref": "#/definitions/tensorflowTensorShapeProto",
          "description": "Shape of the tensor.  TODO(touts): sort out the 0-rank issues."
        },
        "version_number": {
          "type": "integer",
          "format": "int32",
          "description": "Version number.\n\nIn version 0, if the \"repeated xxx\" representations contain only one\nelement, that element is repeated to fill the shape.  This makes it easy\nto represent a constant Tensor with a single value."
        },
        "tensor_content": {
          "type": "string",
          "format": "byte",
          "description": "Serialized raw tensor content from either Tensor::AsProtoTensorContent or\nmemcpy in tensorflow::grpc::EncodeTensorToByteBuffer. This representation\ncan be used for all tensor types. The purpose of this representation is to\nreduce serialization overhead during RPC call by avoiding serialization of\nmany repeated small items."
        },
        "half_val": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          },
          "description": "DT_HALF, DT_BFLOAT16. Note that since protobuf has no int16 type, we'll\nhave some pointless zero padding for each value here."
        },
        "float_val": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          },
          "description": "DT_FLOAT."
        },
        "double_val": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          },
          "description": "DT_DOUBLE."
        },
        "int_val": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          },
          "description": "DT_INT32, DT_INT16, DT_INT8, DT_UINT8."
        },
        "string_val": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "title": "DT_STRING"
        },
        "scomplex_val": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "float"
          },
          "description": "DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real\nand imaginary parts of i-th single precision complex."
        },
        "int64_val": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          },
          "title": "DT_INT64"
        },
        "bool_val": {
          "type": "array",
          "items": {
            "type": "boolean",
            "format": "boolean"
          },
          "title": "DT_BOOL"
        },
        "dcomplex_val": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          },
          "description": "DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real\nand imaginary parts of i-th double precision complex."
        },
        "resource_handle_val": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/tensorflowResourceHandleProto"
          },
          "title": "DT_RESOURCE"
        },
        "variant_val": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/tensorflowVariantTensorDataProto"
          },
          "title": "DT_VARIANT"
        },
        "uint32_val": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "title": "DT_UINT32"
        },
        "uint64_val": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "DT_UINT64"
        }
      },
      "description": "Protocol buffer representing a tensor."
    },
    "tensorflowTensorShapeProto": {
      "type": "object",
      "properties": {
        "dim": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TensorShapeProtoDim"
          },
          "description": "Dimensions of the tensor, such as {\"input\", 30}, {\"output\", 40}\nfor a 30 x 40 2D tensor.  If an entry has size -1, this\ncorresponds to a dimension of unknown size. The names are\noptional.\n\nThe order of entries in \"dim\" matters: It indicates the layout of the\nvalues in the tensor in-memory representation.\n\nThe first entry in \"dim\" is the outermost dimension used to layout the\nvalues, the last entry is the innermost dimension.  This matches the\nin-memory layout of RowMajor Eigen tensors.\n\nIf \"dim.size()\" \u003e 0, \"unknown_rank\" must be false."
        },
        "unknown_rank": {
          "type": "boolean",
          "format": "boolean",
          "description": "If true, the number of dimensions in the shape is unknown.\n\nIf true, \"dim.size()\" must be 0."
        }
      },
      "description": "Dimensions of a tensor."
    },
    "tensorflowVariantTensorDataProto": {
      "type": "object",
      "properties": {
        "type_name": {
          "type": "string",
          "description": "Name of the type of objects being serialized."
        },
        "metadata": {
          "type": "string",
          "format": "byte",
          "description": "Portions of the object that are not Tensors."
        },
        "tensors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/tensorflowTensorProto"
          },
          "description": "Tensors contained within objects being serialized."
        }
      },
      "description": "Protocol buffer representing the serialization format of DT_VARIANT tensors."
    }
  }
}
